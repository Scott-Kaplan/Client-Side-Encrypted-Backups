// DONE fedora (10G virtual machine)
// DONE modify install.sh
	// DONE change hard code of "/home/scott" to capture everything prior to the last slash
// DONE run build.sh seperate to ensure it displays ok
// DONE smallRestore cb ad
// DONE largeRestore ad
// in logSizeOfBackup binary, also print total files in backup
// smallBackup
// largeBackup

// arch
// DONE modify install.sh
// run build.sh seperate to ensure it displays ok
// smallBackup
// smallRestore
// largeBackup
// largeRestore

// centos
// DONE modify install.sh
// smallBackup
// largeBackup
// run build.sh seperate to ensure it displays ok

// DONE debian 9 (1.5G memory, 10G)
// DONE modify install.sh
// smallBackup
// largeBackup
// run build.sh seperate to ensure it displays ok

// gentoo
// modify install.sh
// smallBackup
// largeBackup
// run build.sh seperate to ensure it displays ok

// opensuse (5G virtual machine)
// modify install.sh
// smallBackup
// largeBackup
// run build.sh seperate to ensure it displays ok

// slackware
// modify install.sh
// smallBackup
// largeBackup
// run build.sh seperate to ensure it displays ok

// ubuntu 14.04
// DONE modify install.sh
// smallBackup
// enable ssh public key
// smallBackup
// largeBackup
// run build.sh seperate to ensure it displays ok

// ubuntu 18.04
// DONE modify install.sh
// smallBackup
// enable ssh public key
// smallBackup
// largeBackup
// run build.sh seperate to ensure it displays ok

// ubuntu 16.04
// DONE modify install.sh
// make copy of config file 1 that has problem
// on 16.04, do small backup and answer 'n' to wanting to continue.  Confirm that Exiting looks symetrical above and below.  On 14.04 its not as there is an extra line after "Exiting"
// smallBackup
// enable ssh public key
// smallBackup
// largeBackup
// ensure size in log file is correct
// run build.sh seperate to ensure it displays ok

----------------------------------------------------
----------------------------------------------------
----------------------------------------------------
// done or intentionally didn't take action
----------------------------------------------------
----------------------------------------------------
----------------------------------------------------

1 // see when doing the backup with the 2 large .iso, the percentage it jumps from to get to 100% since the calculation won't take into account compression of the tar command

//--- did this with a 200MB file.  Couldn't tell that it skipped at all.  The skipping at the end to 100% wouldn't matter.  The //only thing that matters is that the user sees the percentage going up.  They'd be happy if it went to 100% sooner.

2 //race condition
//When decrypting, got this.  Shouldn't have happened
//Progress of decrypting your backup
//72.7001%        
//ls: cannot access $HOME/.cloudbuddy/restore/e6230-primary**2018-10-02__05:47am.XVovcv: No such file or directory
//Done âœ”

//race condition
//When decrypting, got this.  Shouldn't have happened
//Progress of decrypting your backup
//18.3954%        
//ls: cannot access $HOME/.cloudbuddy/restore/e6230-primary**2018-10-02__05:47am.*: No such file or directory $HOME/.cloudbuddy/restore/scriptThatRestoresTheBackup: line 45: 16747 Segmentation fault      (core dumped) "$HOME/codeBlockProjects/open source/actOnCcryptStatus/bin/Release/actOnCcryptStatus" restore

3 //to get sftp to fail naturally, just wait more than 1 minute and will get this

//About to start the transfer
//Please hang on a few seconds ... (up to a minute)

//<user>@<email_domain>@cloudbuddy.cloud's password: 
//Couldn't read packet: Connection reset by peer
//  Error: The transfer didn't finish - so exiting ...

4 // If the backup is less than 1KB, units won't show.  Example: if size of backup was 248 bytes, this is what shows
//Size of the backup
//248

5 // if a user restores a backup that has already been restored on their computer, decided against asking them whether its ok to delete everything that was there from their last restore before blowing it away.  It is necessary to be blown away frist otherwise the untar progress % complete will intially show greater than 100%.  This is relative to the line in the restore binary
//<<tab0<<"rm -rf "<<restorePath<<endl

6 // When restoring a large backup with lots of directories, there is concern over whether the untar progress % complete could be done within 1 second.  Decided not to take action.  Here is the block of code in actOnTarStatus that deals with this-
//else // purpose == "restore"
//Notes:
//if what is being restored is large and has lots of directories
//the below may not finish within 1 second.
//examples)
//[1]
//did 6gb directory ($HOME/temp/test/test).  it had very few
//directories so it easily finsihed within 1 second
//[2]
//did 64Gb directory ($HOME/temp) which had many subdirectories
//from the command line, this took many seconds.  by running the
//below on such a large directory the behavior of the below code
//is unknown.  At best it just might not print any % complete
//at each second, however than the user may deduce that it is
//hung when its not.  At worst, it would print something unknown
//consider testing this.
//Tested with 150MB backup.  it worked perfect.  Its possible
//that even with large backups with lots of directories that this
//would work fine since it would know what it just restored to that point
//and wouldn't have to think about it - the same way as du -sb command
//twice on $HOME/temp is very fast the second time

7 // remove scott from all source code

8 // for now not going to consider proxy server support 

9 // in install.sh at the beginning, let the user know that backup and restore are binaries that will be copied into /usr/local/bin and is it ok to proceed?
// Reason didn't do this:  nothing is currently in the 16.04 or 18.04 repo that is a binary called backup or restore

10 // change EXIT_SUCCESS to EXIT_FAILURE when the program didn't finish like it should have
// didn't take action because both are the same: https://stackoverflow.com/questions/8867871/should-i-return-exit-success-or-0-from-main

11 // Capitalize the start of comments.  Didn't do this.  No real upside and some comments are even complete sentences

12 // test fileExit() and directoryExist()

13 // tested fileExist() and directoryExist() for all positive and negative paths
/* to test
put these at the beginning of main in backup binary
    test__existenceOfADirectory();
    test__existenceOfAFile();
    exit(EXIT_SUCCESS);
then place these ahead of main()

void test__displayMessage(bool booleanValue, string &whatsBeingTested, string &path)
{
    if (booleanValue)
        cout<<endl<<"This "<<whatsBeingTested<<" exists:  "<<path<<endl<<endl;
    else
        cout<<endl<<"This "<<whatsBeingTested<<" does not exist:  "<<path<<endl<<endl;
}

void test__existenceOfADirectory()
{
    string whatsBeingTested="";
    string path="";
    bool exists=false;

    // 'dirThatDoesntExist' is a non existent directory
    whatsBeingTested="directory";
    path="$HOME/.cloudbuddy/dirThatDoesntExist";
    exists = directoryExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'dirThatDoesntExist dirThatDoesntExist' is a non existent directory
    whatsBeingTested="directory";
    path="$HOME/.cloudbuddy/dirThatDoesntExist dirThatDoesntExist";
    exists = directoryExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'log' is a directory that exists
    whatsBeingTested="directory";
    path="$HOME/.cloudbuddy/log";
    exists = directoryExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'log log' is a directory that exists
    whatsBeingTested="directory";
    path="\"$HOME/.cloudbuddy/log log\"";
    string mkdirCmd="mkdir -p "+path;
    if(system(mkdirCmd.c_str()));
    exists = directoryExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'thisisafile' is a file that exists
    whatsBeingTested="directory";
    path="$HOME/.cloudbuddy/thisisafile";
    string makeFile1Cmd="touch "+path;
    if(system(makeFile1Cmd.c_str()));
    exists = directoryExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'thisisafile thisisafile' is a file that exists
    whatsBeingTested="directory";
    path="\"$HOME/.cloudbuddy/thisisafile thisisafile\"";
    string makeFile2Cmd="touch "+path;
    if(system(makeFile2Cmd.c_str()));
    exists = directoryExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // this ensures that a substring of a directory wasn't found
    whatsBeingTested="directory";
    path="$HOME/.cloudbuddy/lo";
    exists = directoryExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

}

void test__existenceOfAFile()
{
    string whatsBeingTested="";
    string path="";
    bool exists=false;

    // 'howdy1' is a non existent file
    whatsBeingTested="file";
    path="$HOME/.cloudbuddy/howdy1";
    exists = fileExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'howdy1 1' is a non existent file
    whatsBeingTested="file";
    path="$HOME/.cloudbuddy/howdy1 1";
    exists = fileExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'thisisafile' is a file that exists
    whatsBeingTested="file";
    path="$HOME/.cloudbuddy/thisisafile";
    exists = fileExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'thisisafile thisisafile' is a file that exists
    whatsBeingTested="file";
    path="$HOME/.cloudbuddy/thisisafile thisisafile";
    exists = fileExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'log' is a directory that exists
    whatsBeingTested="file";
    path="$HOME/.cloudbuddy/log";
    exists = fileExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // 'log log' is a directory that exists
    whatsBeingTested="file";
    path="$HOME/.cloudbuddy/log log";
    exists = fileExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);

    // this ensures that a substring of a file wasn't found
    whatsBeingTested="file";
    path="$HOME/.cloudbuddy/thisisafil";
    exists = fileExist(path,__FILE__,__LINE__,purpose);
    test__displayMessage(exists,whatsBeingTested,path);
}
*/

14 // check that build.sh is sudo, otherwise print error message

15 // check that install.sh is sudo, otherwise print error message

16 // Check that every path listed in config file 1 exists before running the find command. Otherwise, get find errors on each path that doesn't exist
// done in checkThatAllDirectoriesAndFilesInConfigFile1Exist()

17 // confirm correct error messages when each of these config files doesn't exist
// backup
	// 	DONE 1
	// 	DONE 2
	// 	DONE 3
	// 	DONE 4
	// 	DONE 5
	// 	DONE 6
	//	DONE 7
	//  DONE timeStampMarker
// restore 
	// 	DONE 2
	
18 // confirm correct error messages with each config file where the user didn't add anything
// backup
	// 	DONE 1
	// 	DONE 2
	// 	DONE 3
	// 	DONE 4
// restore 
	// 	DONE 2

19 // use displayError() for everything (except for "Usage:" & openForReading() & openForWriting()) in
// DONE backup
// DONE restore
// DONE staticLibrary_fileUtilities
// DONE actOnCcryptStatus
// DONE	actOnTarStatus

20 // ensure ./smallBackup doesn't end with "Exiting ..." when there were no issues

21 // ensure ./smallRestore doesn't end with "Exiting ..." when there were no issues

22 // ensure that there are no space is in config file 2 for field that needs to be extracted

23 // ensure no spaces in config file 3 for field that needs to be extracted

24 // support spaces in paths found in config file 1

25 // in displayUsage() in backup, change the variable "<<computerName" to this hard coded string "computerName".  The reason is displayUsage() can be called before computerName has a value

26 // call cleanUpAndExit when the user doesn't enter the same encryption password twice when doing a backup

27 // think about building in ability to decrypt/untar without sftp'ing first as it is now.
// nah because most/all of time the user will enter the correct decryption key

28 // call cleanUpAndExit when the user doesn't enter the correct decryption password when doing a restore

29 // test ./smallRestore with wrong ccrypt key

30 // restore bad backup name like blappity
// correctly get-
//Error: Unable to locate the backup "blappity"
//
//
//Exiting ...

31 // cleanUpAndExit should be used in place of "exit 1" in these binaries
  // DONE backup
  // DONE restore

32 // test ./smallBackup with 3 wrong sftp passwords

33 // test displayUsage() in backup

34 // test displayCommandLineArgumentsAreWrong() in
  // backup
  // restore

35 // restore a good named backup where the path to it is incorrect.

36 // rework displayUsage() in restore so it matches the format in backup

37 // test ./smallRestore with 3 wrong sftp passwords

38 // increase percentage to 6 significant digits for tar and ccrypt status - so larger backups show a progress percentage change
// average on the low side encrypt/decrypt per second is say 50Mb.  If say a backup or restore was 10Gb, that would be 1/200 of a change per second which is .005.  If 100Gb, that would be 1/2000 = .0005.  If 1TB that would be 1/20000 = .00005 which would not show up.  If 10TB that would be 1/200000 = .000005. So, 6 digits will show a ccrypt percentage change per second for encrypt/backup even up through (and slightly beyond 10Tb)

39 // test checkForIllegalCharactersInFile() and checkForIllegalCharactersInLine()
// #/home/sc"ott/delete/dirdir - works on 14.04
// #/home/scott/delete/dir"dir - works on 14.04
// #/home/scott/delete/dir" - works on 14.04
//#/home/scott/delete
//	# create dir" - works on 14.04
//  # create dir"dir - works on 14.04
// #/home/sc$ott/delete/dirdir - works on 18.04
// #/home/scott/delete/dir$dir - works on 18.04
// #/home/scott/delete/dir$ - works on 18.04
// #/home/scott/delete
//  # create dir$ - works on 18.04
//  # create dir$dir - works on 18.04

40 // save the size of the encrypted backup into the log file.

41 // ensure all lines wrap at 80
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities

42 // ensure all #includes are used
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities

43 // ensure all handles from ifstream and ofstream are closed  
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities

44 // ensure all #defines, enumerated values and structures members are used
  // N/A actOnCcryptStatus
  // N/A actOnTarStatus
  // N/A backup
  // N/A logSizeOfBackup
  // N/A restore
  // DONE staticLibrary__fileUtilities

45 // remove all unused code
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities

46 // ensure all prototypes are used
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities

47 // ensure all from static libraries are used
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities

48 // ensure all declared file scope variables are used
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities
  
49 // ensure all comments are accurate
  // DONE actOnCcryptStatus
  // DONE actOnTarStatus
  // DONE backup
  // DONE logSizeOfBackup
  // DONE restore
  // DONE staticLibrary__fileUtilities

50 // ensure that the install script makes timestampmarker with timestamp of epoch.

51 // #tested for illegal length in $HOME/.cloudbuddy/[4] computer_name
//0ddcbd19c08c44e58e01d03fd634084eHOWDY

52 // #tested for illegal characters in $HOME/.cloudbuddy/[4] computer_name
//#*0ddcbd19c08c44e58e01d03fd634084

53 // the restore binary now uses the landing directory from the config file instead of the path being passed in
// updated usage
// didn't need to modify github instructions.

54 // the landingDirectory read from the config file does not allow spaces.  If the user enters it, an error message is displayed saying to remove the space

55 // on 18.04, do small backup and answer 'n' to wanting to continue.  Confirm that Exiting looks symetrical above and below.  On 14.04 its not as there is one line before "Exiting" and two lines after
// it was the same on both 14.04 & 16.04, so made it 2 above & 2 below

56 // after a backup and prior to checking for "tar: Removing leading" in the actOnTarOutput.cpp, inject "howdy" into the tarOutputPath like below; then ensure that tar gives warning that the output was unexpected.
// string cmd="echo howdy >> "+globalString.tarOutputPath;
// if(system(cmd.c_str()));
